# -*- coding: utf-8 -*-
"""tcp-solution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-jDAdXxNVujAPTY0KahXc1iPVlmINeGe
"""

import math
import random
import matplotlib.pyplot as plt

class City:
    def __init__(self, num, x, y):
        self.num = num
        self.x = x
        self.y = y
    
    def print_info(self):
        print("City:", self.num, "Coordinates:", str(self.x) + ",", self.y)

cities = []

def read_file():
    
    file = open("Cities Coordinates.txt", 'r')

    for line in file.readlines()[3:-1]: #4. satırdan itibaren okumaya başla
        city_info = line.split()
        city = City(int(city_info[0]), int(city_info[1]), int(city_info[2]))
        cities.append(city)
    
    file.close()

read_file()
for c in cities:
  c.print_info()

!ls

class Individual:
    def __init__(self,tour_order=None):
        self.tour_order=tour_order;
        self.fitness=None

    def calculate_distance(self, city_1, city_2):
        return math.sqrt((city_1.x - city_2.x)**2 + (city_1.y - city_2.y)**2)

    def calculate_fitness(self):
        total_distance = 0
        for count, city in enumerate(self.tour_order):
            if count == len(self.tour_order)- 1:
                break;
            total_distance += self.calculate_distance(self.tour_order[count], self.tour_order[count+1])
        total_distance += self.calculate_distance(self.tour_order[-1], self.tour_order[0])
        
        self.fitness=total_distance

    def print_solution(self):
        text = ""
        for city in self.tour_order:
            text += str(city.num) + ", "
        text += "\nTotal Distance:" + str(self.fitness)

        return text

import random
import copy

class GA:
  def __init__(self,cities,pop_size,termination):
    self.cities=cities
    self.pop_size=pop_size;
    self.population=[]
    self.termination=termination

  def init_evolve_population(self):
    for x in range(self.pop_size):
      temp = copy.deepcopy(self.cities)
      random.shuffle(temp)
      newsolution=Individual(temp)#listeyi karıştırır
      newsolution.calculate_fitness()
      self.population.append(newsolution) 

  def crossover(self, parent1, parent2): #onepoint crossover
    child1=[]
    child2=[]
    cross_position = random.randint(1, len(parent1.tour_order))
    for i in range(0,cross_position):
      child1.append(parent1.tour_order[i])
      child2.append(parent2.tour_order[i])
    for i in range(cross_position,len(parent1.tour_order)):
      child1.append(parent2.tour_order[i])
      child2.append(parent1.tour_order[i])
      
    return Individual(child1),Individual(child2)

  def mutation(self,tour_order): #swap mutation
      tour_order=copy.deepcopy(tour_order)
      if random.random() < 0.3:   # %20 oranla mutasyon uygula
        mut_pos1 = random.randint(0, len(tour_order) - 1)
        mut_pos2 = random.randint(0, len(tour_order) - 1)

        temp=tour_order[mut_pos1]
        tour_order[mut_pos1]=tour_order[mut_pos2]
        tour_order[mut_pos2]=temp
      return Individual(tour_order)

  def parent_selection(self): # crossover yapılacak parentları seçme

    best=copy.deepcopy(sorted(self.population,key=lambda x: x.fitness)[0])
    random_=copy.deepcopy(self.population[random.randint(1,self.pop_size-1)])

    return best,random_

  def worst_parent_selection(self): # silinecek parentları seçme

    worst1=sorted(self.population,key=lambda x: x.fitness)[-1]
    worst2=sorted(self.population,key=lambda x: x.fitness)[-2]

    index1=self.population.index(worst1)
    index2=self.population.index(worst2)

    return index1,index2
  def start_GA(self):

    self.init_evolve_population()
    draw_plot(self.population[0])
    generation=0
    while(generation<self.termination):
      for indv in self.population:
        p1,p2=self.parent_selection()
        c1,c2=self.crossover(p1,p2)
        c1=self.mutation(c1.tour_order)
        c2=self.mutation(c2.tour_order)

        c1.calculate_fitness()
        c2.calculate_fitness()

        i1,i2=self.worst_parent_selection()
        self.population[i1]=c1
        self.population[i2]=c2
      
      print(generation,sorted(self.population,key=lambda x: x.fitness)[0].fitness)
      generation=generation+1

    return sorted(self.population,key=lambda x: x.fitness)[0]

def string_representation(solution):
  with open("best_result.txt", "w") as f:
    f.write(solution.print_solution())

def draw_plot(best):
  import matplotlib.pyplot as plt
  plt.plot([c.x for c in best.tour_order], [c.y for c in best.tour_order])
  plt.show()

ga=GA(cities,50,1000)
best = ga.start_GA()
string_representation(best)
draw_plot(best)

ga=GA(cities,50,2000)
best = ga.start_GA()
string_representation(best)
draw_plot(best)

ga=GA(cities,50,5000)
best = ga.start_GA()
string_representation(best)
draw_plot(best)

ga=GA(cities,100,1000)
best = ga.start_GA()
string_representation(best)
draw_plot(best)

ga=GA(cities,100,2000)
best = ga.start_GA()
string_representation(best)
draw_plot(best)

ga=GA(cities,100,5000)
best = ga.start_GA()
string_representation(best)
draw_plot(best)

ga=GA(cities,200,1000)
best = ga.start_GA()
string_representation(best)
draw_plot(best)

ga=GA(cities,200,2000)
best = ga.start_GA()
string_representation(best)
draw_plot(best)

ga=GA(cities,200,5000)
best = ga.start_GA()
string_representation(best)
draw_plot(best)

